---
title: 【算法】约瑟夫问题
tags:
 - 算法学习
---
  
这个问题是以弗拉维奥·约瑟夫命名的，他是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。 
—— 【约瑟夫问题】维基百科

题目是这样的：
```
0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
```

 - 通常有两种解法，模拟解法和数学解法
 - 模拟的方法可以使用数组或者链表也进行模拟，数组使用取余数和标记法来进行模拟，链表就使用循环链表，找到一个删除一个即可找到最后一个。
 - 这里主要讲一下数学解法：
 - 就拿0、1、2、3、4来说，每数3个然出去一个，即他们出去的顺序是2、0、4、1。
 - 而对于最后剩下的数，3 ，来说，他的数组位置是0，
 - 那进行第一次反推，上一次退出时，有两个数字，那么上次3的位置就在(0 + 3) % 2 = 1
 - 再上一次退出时，还有3个数字，那么这次3的位置在(1 + 3) % 3= 1
 - 继续往上推即可得道(1 + 3) % 4= 0，(0 + 3) %5= 3
 - 即最初全部数字都还在的时候，3这个数字在数组的位置是3。
 - 由此可以推出公式 **(当前index + m) % 上一轮剩余数字的个数**
 - 附上代码

```
 int lastRemaining(int n, int m) {//n是人数，m是每m下退出一个
        if(n < 1 || m < 1){
            return -1;
        }
        int last = 0;
        // i 代表的是人数
        for(int i = 2;i<=n;++i){
            last = (last+m)%i;
        }
        return last;
    }
```

 