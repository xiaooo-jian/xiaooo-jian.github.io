---
title: 【算法】二叉树问题
tags:
  - 算法学习
  - LeetCode
---


都是LeetCode做的关于二叉树的问题，统一这里放一放，点击标题蓝链之前前往。



# 199. [二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)
变种的层序遍历，从上往下，从右边往左边，每行读的第一个就是右视图啦

``` cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> q;
        vector<int> res;
        if(!root) return res;
        q.push(root);
        while(!q.empty()){
            int num = q.size();
            res.push_back(q.front()->val);
            while(num--){
                TreeNode *temp  = q.front();
                q.pop();
                if (temp->right) q.push(temp->right);
			    if (temp->left) q.push(temp->left);
            }
        }
        return res;
    }
};
```

# [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)


简单的递归调用
``` cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==NULL){
            return 0;
        }
        int right = maxDepth(root->right);
        int left = maxDepth(root->left);
        return right>left ? right+1 : left+1;
    }
};
```


# [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

也是递归调用，但比上面那个麻烦一点
``` cpp
class Solution {
public:
    int len = INT_MIN;
    int deep(TreeNode* root){
        if(!root) return 0;
        int len_left = deep(root->left);
        int len_right = deep(root->right);
        len = max (len,len_right+len_left);
        return 1+max(len_left,len_right);
    }
    int diameterOfBinaryTree(TreeNode* root) {
        if(!root) return 0;
        deep(root);
        return len;
    }
};
```

