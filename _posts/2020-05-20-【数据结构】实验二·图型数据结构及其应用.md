---
title: 【数据结构】实验二·图型数据结构及其应用
tags:
 - 数据结构
 - 实验
---

## 实验题目：图的建立、遍历及其应用

 - 设图结点的元素类型为char，建立一个不少于8个顶点的带权无向图G，实现以下图的各种基本操作的程序：
 - ① 用邻接矩阵作为储结构存储图G并输出该邻接矩阵；
 - ② 用邻接链表作为储结构存储图G并输出该邻接链表；
 - ③ 按DFS算法输出图G中顶点的遍历序列；
 - ④ 按BFS算法输出图G中顶点的遍历序列；
 - ⑤ 用Prime算法从某个指定的顶点出发(或者Kruskal算法)输出图G的最小生成树；（要求把最小生成树的各条边输出成A-B,B-C或者(A,B,weight)的形式）
 - ⑥ 求从有向图的某个节点出发到其余各顶点的最短路径和最短路径值；（带权有向图）
 - ⑦ 用狄克斯特拉（Dijkastra）算法或者Floyd算法求每对顶点之间的最短路径；（带权有向图，选做）
 - ⑧ 主函数通过函数调用实现以上各项操作。


## 无向带权图（邻接矩阵）

``` c
#include"Queue.h"
#include<stdio.h>
#include<stdlib.h>
#pragma warning(disable:6031)
#pragma warning(disable:4996)
#pragma warning(disable:6011)


int visited[Max];

/*邻接矩阵*/
typedef struct {
	char vexs[Max]; //顶点表
	int arc[Max][Max]; //邻接矩阵
	int numVertexes, numEdges; //顶点数、边数
}MGraph;

/*边集数组*/
typedef struct {
	int begin;
	int end;
	int weight;
}Edge;

void CreateMGraph(MGraph& G);
void ShowMGraph(MGraph G);
void DFS(MGraph G, int i);
void DFSTraverse(MGraph G);

void BFSTraverse(MGraph G);

void MCST_Prim(MGraph G);

void TransEdge(Edge edge[], MGraph G);
void MCST_Kruskal(MGraph G);





int main() {
	MGraph G;
	CreateMGraph(G);
	printf("打印邻接矩阵：\n");
	ShowMGraph(G);
	printf("\n");
	printf("深搜结果为：\n");
	DFSTraverse(G);
	printf("\n");
	printf("广搜结果为：\n");
	BFSTraverse(G);
	printf("\n");
	printf("最小生成树（Prim算法）\n");
	MCST_Prim(G);
	printf("\n");
	printf("最小生成树（kruskal算法）\n");
	MCST_Kruskal(G);
	printf("\n");
}



void CreateMGraph(MGraph& G) {//构建邻接矩阵
	int i, j, k, w;
	FILE* f = fopen("graph.txt","r");
	fscanf(f,"%d %d", &G.numVertexes, &G.numEdges);
	for (i = 0; i < G.numVertexes; i++) {
		fscanf(f,"%c",&G.vexs[i]);
		//printf("读取到字符%c\n",G.vexs[i]);
	}
	for (i = 0; i < G.numEdges; i++)
		for (j = 0; j < G.numEdges; j++)
			G.arc[i][j] = INFINITY;
	for (k = 0; k < G.numEdges; k++) {
		fscanf(f,"%d %d %d", &i, &j, &w);
		G.arc[i][j] = G.arc[j][i] = w;
		//printf("读取到 %c 到 %c 的权为 %d\n", G.vexs[i],G.vexs[j] ,w);
	}
	fclose(f);
}

void ShowMGraph(MGraph G) {//打印邻接矩阵
	printf("   ");
	for (int i = 0; i < G.numVertexes; i++) {
		printf("%c   ", G.vexs[i]);
	}
	printf("\n");
	for (int i = 0; i < G.numVertexes; i++) {
		printf("%c  ",G.vexs[i]);
		for (int j = 0; j < G.numVertexes; j++) {
			if (G.arc[i][j] == INFINITY)
				printf("∞  ");
			else
				printf("%-3d ", G.arc[i][j]);
		}
		printf("\n");
	}
}

void DFS(MGraph G, int i) {
	int j;
	visited[i] = 1;
	printf("%c ", G.vexs[i]);
	for (j = 0; j < G.numVertexes; j++)
		if (G.arc[i][j] == 1 && !visited[j])
			DFS(G, j);
}

void DFSTraverse(MGraph G) {//深搜
	int i;
	for (i = 0; i < G.numVertexes; i++)
		visited[i] = 0;
	for (i = 0; i < G.numVertexes; i++)
		if (!visited[i])
			DFS(G, i);
}

void BFSTraverse(MGraph G) {//广搜
	int i, j;
	Pqueue Q = (Pqueue)malloc(sizeof(Queue));
	for (i = 0; i < G.numVertexes; i++)
		visited[i] = 0;
	CreateQueue(Q);
	for (i = 0; i < G.numVertexes; i++) {
		if (!visited[i]) {
			visited[i] = 1;
			printf("%c ", G.vexs[i]);
			Enqueue(Q, i);
			while (Q->front != Q->rear) {
				i=Dequeue(Q);
				for (j = 0; j < G.numVertexes; j++) {
					if (G.arc[i][j] != INFINITY && !visited[j]) {
						visited[j] = 1;
						printf("%c ", G.vexs[j]);
						Enqueue(Q, j);
					}
				}
			}
		}
	}
}


void MCST_Prim(MGraph G) {
	int  min,i, j, k;
	int adjvex[Max];
	int lowcost[Max];
	lowcost[0] = 0;
	adjvex[0] = 0;

	for (i = 1; i < G.numVertexes; i++) {
		lowcost[i] = G.arc[0][i];
		adjvex[i] = 0;
	}
	for (i = 1; i < G.numVertexes; i++) {
		min = INFINITY;
		j = 1;
		k = 0;
		while (j < G.numVertexes) {
			if (lowcost[j] != 0 && lowcost[j] <min) {
				min = lowcost[j];
				k = j;
			}
			j++;
		}
		printf("%c-%c  ", G.vexs[adjvex[k]], G.vexs[k]);
		lowcost[k] = 0;
		for (j = 1; j < G.numVertexes; j++) {
			if (lowcost[j] != 0 && G.arc[k][j] < lowcost[j]) {
				lowcost[j] = G.arc[k][j];
				adjvex[j] = k;
			}
		}
	}
}

int Find(int* parent, int f) {
	while (parent[f] > 0)
		f = parent[f];
	return f;
}

void TransEdge(Edge edge[], MGraph G) {
	int i, j, k = 0;
	for (i = 0; i < G.numEdges; i++) {
		for (j = 0; j < G.numEdges; j++)
		{
			if (G.arc[i][j] != 0 && G.arc[i][j] != INFINITY)
			{
				edge[k].begin = i;
				edge[k].end = j;
				edge[k].weight = G.arc[i][j];
				k++;
			}
		}
	}
	for (i = 0; i < k - 1; i++) {
		for (j = i + 1; j < k; j++)
		{
			if (edge[i].weight > edge[j].weight)
			{
				Edge T;
				T = edge[i]; edge[i] = edge[j]; edge[j] = T;
			}
		}
	}
}

void MCST_Kruskal(MGraph G) {
	int i, n, m;
	static Edge edges[Max] ;
	int parent[Max];

	TransEdge(edges, G);

	for (i = 0; i < G.numVertexes; i++)
		parent[i] = 0;
	for (i = 0; i < G.numEdges; i++) {
		n = Find(parent, edges[i].begin);
		m = Find(parent, edges[i].end);
		if (n != m) {
			parent[n] = m;
			printf("(%c,%c) %d   ", G.vexs[edges[i].begin], G.vexs[edges[i].end],edges[i].weight);
		}
	}
}

```


## 无向带权图（邻接表）
``` c
#include"Queue.h"
#include<stdio.h>
#include<stdlib.h>
#pragma warning(disable:6031)
#pragma warning(disable:4996)
#pragma warning(disable:6011)


int visited[Max];

/*邻接表*/

typedef struct EdgeNode { //边
	int adjvwx;	//顶点对应下标
	int weight;	//权
	struct EdgeNode* next;	//下一个邻接点
}EdgeNode;

typedef struct VertexNode {  //顶点
	char data;	//数据
	EdgeNode* firstEdge; // 边 表头指针
}VertexNode, Adjlist[Max];

typedef struct {
	Adjlist adjList;
	int numVertexes, numEdges;
}GraphAdjList;


void CreateALGraph(GraphAdjList& G);
void ShowGraphAdjList(GraphAdjList G);
void DFS(GraphAdjList G, int i);
void DFSTraverse(GraphAdjList G);

void BFSTraverse(GraphAdjList G);

void MCST_Prim(GraphAdjList G);

int Find(int* parent, int f);

void MCST_Kruskal(GraphAdjList G);

int main() {
	GraphAdjList G;
	CreateALGraph(G);

	ShowGraphAdjList(G);

	printf("深搜结果为：\n");
	DFSTraverse(G);
	printf("\n");
	printf("广搜结果为：\n");
	BFSTraverse(G);
	printf("\n");

}

void CreateALGraph(GraphAdjList& G) {
	int i, j, k, w;
	EdgeNode* e = NULL;
	FILE* f = fopen("graph.txt", "r");
	fscanf(f,"%d %d", &G.numVertexes, &G.numEdges);
	for (i = 0; i < G.numVertexes; i++) {
		fscanf(f,"%c",&G.adjList[i].data);
		//printf("读取到字符%c\n", G.adjList[i].data);
		G.adjList[i].firstEdge = NULL; //将边表置位空表
	}
	for (k = 0; k < G.numEdges; k++) {
		fscanf(f,"%d %d %d", &i, &j, &w);
		//printf("读取到 %d 到 %d 的权为 %d\n", i, j, w);
		e = (EdgeNode*)malloc(sizeof(EdgeNode));
		e->adjvwx = j;
		e->weight = w;
		e->next = G.adjList[i].firstEdge;
		G.adjList[i].firstEdge = e;

		e = (EdgeNode*)malloc(sizeof(EdgeNode));
		e->adjvwx = i;
		e->weight = w;
		e->next = G.adjList[j].firstEdge;
		G.adjList[j].firstEdge = e;
	}
}

void ShowGraphAdjList(GraphAdjList G) {
	for (int i = 0; i < G.numVertexes; i++) {
		EdgeNode* temp = G.adjList[i].firstEdge;
		printf("%c  ", G.adjList[i].data);
		while (temp) {
			printf("%c(%d)--", G.adjList[temp->adjvwx].data,temp->weight);
			temp = temp->next;
		}
		printf("\n");
	}
}

void DFS(GraphAdjList G, int i) {
	EdgeNode* temp = NULL;
	visited[i] = 1;
	printf("%c ", G.adjList[i].data);
	temp = G.adjList[i].firstEdge;
	while (temp) {
		if (!visited[temp->adjvwx])
			DFS(G, temp->adjvwx);
		temp = temp->next;
	}
}

void DFSTraverse(GraphAdjList G) {
	int i;
	for (i = 0; i < G.numVertexes; i++)
		visited[i] = 0;
	for (i = 0; i < G.numVertexes; i++)
		if (!visited[i])
			DFS(G, i);
}


void BFSTraverse(GraphAdjList G) {
	int i;
	EdgeNode* p;
	Pqueue Q = (Pqueue)malloc(sizeof(Queue));
	for (i = 0; i < G.numVertexes; i++)
		visited[i] = 0;
	CreateQueue(Q);
	for (i = 0; i < G.numVertexes; i++) {
		if (!visited[i]) {
			visited[i] = 1;
			printf("%c ", G.adjList[i].data);
			Enqueue(Q, i);
			while (Q->front != Q->rear) {
				i = Dequeue(Q);
				p = G.adjList[i].firstEdge;
				while (p) {
					if (!visited[p->adjvwx]){
						visited[p->adjvwx] = 1;
						printf("%c ", G.adjList[p->adjvwx].data);
						Enqueue(Q, p->adjvwx);
					}
					p = p->next;
				}
			}
		}
	}
}


```

## 有向带权图（邻接矩阵）
``` c
#include"Queue.h"
#include<stdio.h>
#include<stdlib.h>
#pragma warning(disable:6031)
#pragma warning(disable:4996)
#pragma warning(disable:6011)

int Pathmatirx[Max];
int ShortPathTable[Max];

/*邻接矩阵*/
typedef struct {
	char vexs[Max]; //顶点表
	int arc[Max][Max]; //邻接矩阵
	int numVertexes, numEdges; //顶点数、边数
}MGraph;

void CreateMGraph(MGraph& G);
void ShowMGraph(MGraph G);
void ShortestPath_Dijkstra(MGraph G, int p);
int main() {


	MGraph G;
	CreateMGraph(G);
	printf("打印邻接矩阵：\n");
	ShowMGraph(G);
	printf("\n");
	ShortestPath_Dijkstra(G, 0);
	for (int i = 1; i < G.numVertexes; i++) {
		printf("%c->", G.vexs[Pathmatirx[i]]);
	}
	printf("\n");
	for (int i = 0; i < G.numVertexes; i++) {
		printf("%d   ", ShortPathTable[i]);
	}
}


void CreateMGraph(MGraph& G) {//构建邻接矩阵
	int i, j, k, w;
	FILE* f = fopen("graph1.txt", "r");
	fscanf(f, "%d %d", &G.numVertexes, &G.numEdges);
	for (i = 0; i < G.numVertexes; i++) {
		fscanf(f, "%c", &G.vexs[i]);
		//printf("读取到字符%c\n",G.vexs[i]);
	}
	for (i = 0; i < G.numEdges; i++)
		for (j = 0; j < G.numEdges; j++)
			G.arc[i][j] = INFINITY;
	for (k = 0; k < G.numEdges; k++) {
		fscanf(f, "%d %d %d", &i, &j, &w);
		G.arc[i][j] = w;
		//printf("读取到 %c 到 %c 的权为 %d\n", G.vexs[i],G.vexs[j] ,w);
	}
	fclose(f);
}


void ShowMGraph(MGraph G) {
	printf("   ");
	for (int i = 0; i < G.numVertexes; i++) {
		printf("%c   ", G.vexs[i]);
	}
	printf("\n");
	for (int i = 0; i < G.numVertexes; i++) {
		printf("%c  ", G.vexs[i]);
		for (int j = 0; j < G.numVertexes; j++) {
			if (G.arc[i][j] == INFINITY)
				printf("∞  ");
			else
				printf("%-3d ", G.arc[i][j]);
		}
		printf("\n");
	}
}

void ShortestPath_Dijkstra(MGraph G, int p) {
	int v, w, k=0,min;
	int final[Max];
	for (v = 0; v < G.numVertexes; v++) {
		final[v] = 0;
		ShortPathTable[v] = G.arc[p][v];
		Pathmatirx[v] = 0;
	}
	ShortPathTable[p] = 0;
	final[p] = 1;

	for (v = 1; v < G.numVertexes; v++) {
		min = INFINITY;
		for (w = 0; w < G.numVertexes; w++) {
			if (!final[w] && ShortPathTable[w] < min) {
				k = w;
				min = ShortPathTable[w];
			}
		}
		final[k] = 1;
		for(w = 0; w < G.numVertexes; w++) {
			if (!final[w] && (min + G.arc[k][w] < ShortPathTable[w])) {
				ShortPathTable[w] = min + G.arc[k][w];
				Pathmatirx[w] = k;
			}
		}
	}
}
```